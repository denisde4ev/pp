#!/bin/sh

_die_() {
	printf %s\\n >&2 "Error: $1"
	exit "${2-2}"
}

case $1 in
--help)
	printf %s\\n \
		"Usage: ${0##*/} !{printf %s "${VERSION?}"}!(denisde4ev)" \
		"  * STDIN | ${0##*/} > output -- See pp(1) for details and examples" \
		"Syntax:" \
		"  * Lines beginning !! are replaced with the following text evaluated" \
		"      as a shell command." \
		"  * Lines beginning !| are for multiline evaluation" \
		"      lines are parsed untill find line begining with !!" \
		"  * Lines beginning || are replaced with the following text" \
		"      without any modifications" \
		"  * Section !{echo \!\{...\}\!}! on one __LINE__ is replaced by the output of cmd '...'" \
		"  * Variables to use: \$__LINE_NUMBER__ for line no. \$__LINE__ for line itself" \
	;
	exit
	;;
-*)
	_die_ "see --help for usage"
esac

# hope eval wont chane it
NEW_LINE='
'

_readline_() {
	IFS= read -r __LINE__ || {
		case $__LINE__ in
			'') return $?;;
			?*) __pp_eof__='';;
		esac
	}
}


# solved:
# case ${ASH_VERSION+x}${ZSH_VERSION+x}${BASH_VERSION+x} in
# *x*)
# 	_eval_trap_() {
# 		# why create trap instead of: `eval '$1' || die ...`
# 		# reason: `set -e` is not working. https://mywiki.wooledge.org/BashFAQ/105
# 
# 		trap "$2" ERR
# 		eval "$1"
# 		case $? in 0) ;; *) eval "$2"; esac
# 		trap - ERR # remove ERR trap
# 	}
# 	;;
# '')
# 	# trap ERR seems to be only for ksh and bash
# 	# does not run on dash or sh ( and semms to have no alternative , BUT GOT 1 https://stackoverflow.com/a/58297505/10823470 )
# 	# none of this wokrs: `for i in {1..64} EXIT ERR QUIT; do dash -c ' set -eu; trap " PRINT ME, when '$i' : \$?" '$i'; false; echo NEVER PRINT ME  '; done`
# 	_eval_trap_() {
# 		eval "$1" || eval "$2"
# 	}
# esac
#
_eval_trap_() {
	# why create trap instead of: `eval '$1' || die ...`
	# reason: `set -e` is not working. https://mywiki.wooledge.org/BashFAQ/105
	# thanks https://stackoverflow.com/a/58297505/10823470 for sh version

	trap "(exit \$?) && exit || $2" EXIT
	eval "$1"
	case $? in 0) ;; *) eval "trap - EXIT; (exit $?) || $2"; esac
	trap - EXIT # remove ERR trap
}

case ${ASH_VERSION+x}${ZSH_VERSION+x}${BASH_VERSION+x} in
*x*)
	eval "_escape_ () { printf %s\\\\n \"${1//\\'/\\'\\\\\\'\\'}\"; }"
	;;
*)
	_escape_() {
		case $1 in
			*"'"*) printf %s "$1" | sed "s/'/'\\\\''/g; 1 s/^/'/; $ s/$/' /";;
			*) printf %s "'$1'";;
		esac
	}

esac

_pp_() {
	while _readline_; do
		__LINE_NUMBER__=$((__LINE_NUMBER__+1))
		case $__LINE__ in
			!!|!!#*|'!! #'*|'!!	#'*) # fully ignore lines that contains only a comment
			;;
			!!*)
				_eval_trap_ "${__LINE__##!!}" \
					'_die_ "LINE $__LINE_NUMBER__: evaluation error $?" 3' \
				;
			;;
			\|\|*) printf %s${__pp_eof__:-\\n} "${__LINE__#??}";;
			!\|*)
				__PREVLINES__=${__LINE__#??}
				while :; do
					_readline_ || {
						_die_ "expected line that matches '!!*' but got end of file instead" 5
					}
					case $__LINE__ in
						#!||!|#*|'!| #'*|'!|	#'*)
							# DONT: DETECT IF LINE IS A COMMENT:
							# it might not be a coment, but to be a continuation from previous line,
							# for example here document and/or unclosed quote,
							# insane example:
							# ``` sh
							# $ ( sed 's/-/--/g' << '#'EOF; tr - _ << \#EOF2; echo "echo-line:1
							# > #echo-line:2" )
							# > #here-document-for-sed
							# > #EOF
							# > #here-document-for-tr
							# > #EOF2
							# ```
							# ``` sh.output
							# #shere--document--for--sed
							# #here_document_for_tr
							# echo-line:1
							# #echo-line:2
							# ```
						#;;

						!\|*) __PREVLINES__=$__PREVLINES__$NEW_LINE${__LINE__##??};;
						!!*)
							_eval_trap_ "$__PREVLINES__$NEW_LINE${__LINE__##??}" \
								'_die_ "LINES $__LINE_NUMBER__: evaluation error $?" 3' \
							;
							break
						;;
						\|\|*) # nested lin that is trimmed from start, note/TODO: !{}! is not interpreted here
							__pp_tmp__=${__LINE__#??}
							__pp_tmp__=${__pp_tmp__#"${__pp_tmp__%%[!" 	"]*}"}
							__PREVLINES__=$__PREVLINES__$NEW_LINE"printf %s\\\\n $(_escape_ "${__pp_tmp__}")"
						;;
						*) __PREVLINES__=$__PREVLINES__$NEW_LINE"printf %s\\\\n $(_escape_ "$__LINE__")";;
					esac
				done
				unset __PREVLINES__
			;;
			*!\{*\}!*)
				__pp_tmp__=${__LINE__#*\!{}

				# bug/note:
				# on dash: `set -e; a=$( false; echo not-stopped )` does exit and `a=''` as expected.
				# however on bash (at least for newest version 5.1): does not exit and `a=not-stopped`!
				# ref: https://stackoverflow.com/questions/69138072/shopt-s-inherit-errexit-has-no-effect-in-declare-command
				# > errexit behavior is wildly different between individual shell releases,
				# > **not to mention between different shells and even on different calling contexts**
				#
				# consider fix: instead of stdout to use var. maybe `o` short for output.
				# in this way interpreted input will be shorter for inline replacement:
				# `\!{o=$test}\!` = (old) `\!{printf %s "$test"}\!` -> `test`
				_eval_trap_ '__pp_tmp__=$(eval "${__pp_tmp__%\}\!*}")' \
					'_die_ "Line $__LINE_NUMBER__: section evaluation error $?" 3' \
				;


				printf %s%s%s${__pp_eof__:-\\n} \
					"${__LINE__%%\!{*}" \
					"$__pp_tmp__" \
					"${__LINE__##*\}\!}"
				;;
			*)
				printf %s${__pp_eof__:-\\n} "$__LINE__"
			;;
		esac
	done
}

__PP_LVL__=0
pp() {
	__PP_LVL__=$((__PP_LVL__+1)) # allow included scripts to tetect included files level
	case $1 in
		--) shift;;
		-) ;;
		-*) _die_ "No arguments are taken";;
	esac
	case $# in 0) set -- -; esac
	for __FILE__; do
		case $__FILE__ in
			-) _pp_;;
			*) _pp_ < "$__FILE__";;
		esac
	done
}

pp "$@"
